--- origsrc/gst-plugins-good-0.10.31/configure.ac	2012-04-18 03:10:21.443306700 -0500
+++ src/gst-plugins-good-0.10.31/configure.ac	2012-04-18 03:07:00.027786400 -0500
@@ -133,6 +133,8 @@ AM_CONDITIONAL(HAVE_VALGRIND, test ! "x$
 dnl check for gconftool-2
 dnl this macro defines an am conditional, so it needs to be run always
 AM_GCONF_SOURCE_2
+dnl ditto for mateconftool-2
+AM_MATECONF_SOURCE_2
 
 dnl check for documentation tools
 GTK_DOC_CHECK([1.3])
@@ -280,6 +282,18 @@ AG_GST_CHECK_FEATURE(GCONFTOOL, [GConf s
   AC_SUBST(HAVE_GCONFTOOL)
 ])
 
+translit(dnm, m, l) AM_CONDITIONAL(USE_MATECONFTOOL, true)
+AG_GST_CHECK_FEATURE(MATECONFTOOL, [MateConf schemas], , [
+  AC_PATH_PROG(MATECONFTOOL, mateconftool-2, no)
+  if test x$MATECONFTOOL = xno; then
+    AC_MSG_WARN(Not installing MateConf schemas)
+    HAVE_MATECONFTOOL="no"
+  else
+    HAVE_MATECONFTOOL="yes"
+  fi
+  AC_SUBST(HAVE_MATECONFTOOL)
+])
+
 dnl *** set variables based on configure arguments ***
 
 dnl set license and copyright notice
@@ -834,6 +848,12 @@ AG_GST_CHECK_FEATURE(LIBPNG, [Portable N
   AG_GST_PKG_CHECK_MODULES(LIBPNG, libpng >= 1.2)
 ])
 
+dnl *** MateConf ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_MATECONF, true)
+AG_GST_CHECK_FEATURE(MATECONF, [MateConf libraries], mateconfelements, [
+  AG_GST_PKG_CHECK_MODULES(MATECONF, mateconf-2.0)
+])
+
 dnl *** pulseaudio ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_PULSE, true)
 AG_GST_CHECK_FEATURE(PULSE, [pulseaudio plug-in], pulseaudio, [
@@ -1042,6 +1062,8 @@ AM_CONDITIONAL(USE_LIBCACA, false)
 AM_CONDITIONAL(USE_LIBDV, false)
 AM_CONDITIONAL(USE_LIBIEC61883, false)
 AM_CONDITIONAL(USE_LIBPNG, false)
+AM_CONDITIONAL(USE_MATECONF, false)
+AM_CONDITIONAL(USE_MATECONFTOOL, false)
 AM_CONDITIONAL(USE_OSS, false)
 AM_CONDITIONAL(USE_OSS4, false)
 AM_CONDITIONAL(USE_OSX_AUDIO, false)
@@ -1177,6 +1199,7 @@ ext/jack/Makefile
 ext/jpeg/Makefile
 ext/libcaca/Makefile
 ext/libpng/Makefile
+ext/mateconf/Makefile
 ext/pulse/Makefile
 ext/raw1394/Makefile
 ext/shout2/Makefile
@@ -1212,6 +1235,8 @@ tests/files/Makefile
 tests/icles/Makefile
 gconf/Makefile
 gconf/gstreamer.schemas
+mateconf/Makefile
+mateconf/gstreamer.schemas
 common/Makefile
 common/m4/Makefile
 m4/Makefile
--- origsrc/gst-plugins-good-0.10.31/docs/plugins/Makefile.am	2011-12-30 07:59:08.000000000 -0600
+++ src/gst-plugins-good-0.10.31/docs/plugins/Makefile.am	2012-04-18 03:27:31.136201800 -0500
@@ -81,6 +81,10 @@ EXTRA_HFILES = \
 	$(top_srcdir)/ext/libcaca/gstcacasink.h \
 	$(top_srcdir)/ext/libpng/gstpngdec.h \
 	$(top_srcdir)/ext/libpng/gstpngenc.h \
+	$(top_srcdir)/ext/mateconf/gstmateconfaudiosrc.h \
+	$(top_srcdir)/ext/mateconf/gstmateconfaudiosink.h \
+	$(top_srcdir)/ext/mateconf/gstmateconfvideosrc.h \
+	$(top_srcdir)/ext/mateconf/gstmateconfvideosink.h \
 	$(top_srcdir)/ext/raw1394/gstdv1394src.h \
 	$(top_srcdir)/ext/raw1394/gsthdv1394src.h \
 	$(top_srcdir)/ext/soup/gstsouphttpsrc.h \
--- origsrc/gst-plugins-good-0.10.31/docs/plugins/gst-plugins-good-plugins-docs.sgml	2011-12-30 07:59:08.000000000 -0600
+++ src/gst-plugins-good-0.10.31/docs/plugins/gst-plugins-good-plugins-docs.sgml	2012-04-18 03:31:32.573011200 -0500
@@ -107,6 +107,10 @@
     <xi:include href="xml/element-jpegdec.xml" />
     <xi:include href="xml/element-jpegenc.xml" />
     <xi:include href="xml/element-level.xml" />
+    <xi:include href="xml/element-mateconfaudiosrc.xml" />
+    <xi:include href="xml/element-mateconfaudiosink.xml" />
+    <xi:include href="xml/element-mateconfvideosrc.xml" />
+    <xi:include href="xml/element-mateconfvideosink.xml" />
     <xi:include href="xml/element-matroskamux.xml" />
     <xi:include href="xml/element-matroskademux.xml" />
     <xi:include href="xml/element-mj2mux.xml" />
@@ -227,6 +231,7 @@
     <xi:include href="xml/plugin-jack.xml" />
     <xi:include href="xml/plugin-jpeg.xml" />
     <xi:include href="xml/plugin-level.xml" />
+    <xi:include href="xml/plugin-mateconfelements.xml" />
     <xi:include href="xml/plugin-matroska.xml" />
     <xi:include href="xml/plugin-monoscope.xml" />
     <xi:include href="xml/plugin-mulaw.xml" />
--- origsrc/gst-plugins-good-0.10.31/docs/plugins/gst-plugins-good-plugins-sections.txt	2012-02-20 18:52:45.000000000 -0600
+++ src/gst-plugins-good-0.10.31/docs/plugins/gst-plugins-good-plugins-sections.txt	2012-04-18 03:38:08.437653300 -0500
@@ -1284,6 +1284,62 @@
 </SECTION>
 
 <SECTION>
+<FILE>element-mateconfaudiosrc</FILE>
+<TITLE>mateconfaudiosrc</TITLE>
+GstMateConfAudioSrc
+<SUBSECTION Standard>
+GstMateConfAudioSrcClass
+GST_MATECONF_AUDIO_SRC
+GST_IS_MATECONF_AUDIO_SRC
+GST_TYPE_MATECONF_AUDIO_SRC
+GST_MATECONF_AUDIO_SRC_CLASS
+GST_IS_MATECONF_AUDIO_SRC_CLASS
+gst_mateconf_audio_src_get_type
+</SECTION>
+
+<SECTION>
+<FILE>element-mateconfaudiosink</FILE>
+<TITLE>mateconfaudiosink</TITLE>
+GstMateConfAudioSink
+<SUBSECTION Standard>
+GstMateConfAudioSinkClass
+GST_MATECONF_AUDIO_SINK
+GST_IS_MATECONF_AUDIO_SINK
+GST_TYPE_MATECONF_AUDIO_SINK
+GST_MATECONF_AUDIO_SINK_CLASS
+GST_IS_MATECONF_AUDIO_SINK_CLASS
+gst_mateconf_audio_sink_get_type
+</SECTION>
+
+<SECTION>
+<FILE>element-mateconfvideosrc</FILE>
+<TITLE>mateconfvideosrc</TITLE>
+GstMateConfVideoSrc
+<SUBSECTION Standard>
+GstMateConfVideoSrcClass
+GST_MATECONF_VIDEO_SRC
+GST_IS_MATECONF_VIDEO_SRC
+GST_TYPE_MATECONF_VIDEO_SRC
+GST_MATECONF_VIDEO_SRC_CLASS
+GST_IS_MATECONF_VIDEO_SRC_CLASS
+gst_mateconf_video_src_get_type
+</SECTION>
+
+<SECTION>
+<FILE>element-mateconfvideosink</FILE>
+<TITLE>mateconfvideosink</TITLE>
+GstMateConfVideoSink
+<SUBSECTION Standard>
+GstMateConfVideoSinkClass
+GST_MATECONF_VIDEO_SINK
+GST_IS_MATECONF_VIDEO_SINK
+GST_TYPE_MATECONF_VIDEO_SINK
+GST_MATECONF_VIDEO_SINK_CLASS
+GST_IS_MATECONF_VIDEO_SINK_CLASS
+gst_mateconf_video_sink_get_type
+</SECTION>
+
+<SECTION>
 <FILE>element-matroskamux</FILE>
 <TITLE>matroskamux</TITLE>
 GstMatroskaMux
--- origsrc/gst-plugins-good-0.10.31/docs/plugins/inspect/plugin-mateconfelements.xml	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/docs/plugins/inspect/plugin-mateconfelements.xml	2012-04-18 03:29:21.195496800 -0500
@@ -0,0 +1,49 @@
+<plugin>
+  <name>mateconfelements</name>
+  <description>elements wrapping the GStreamer/MateConf audio/video output settings</description>
+  <filename>../../ext/mateconf/.libs/libgstmateconfelements.so</filename>
+  <basename>libgstmateconfelements.so</basename>
+  <version>0.10.31</version>
+  <license>LGPL</license>
+  <source>gst-plugins-good</source>
+  <package>GStreamer Good Plug-ins source release</package>
+  <origin>Unknown package origin</origin>
+  <elements>
+    <element>
+      <name>mateconfaudiosink</name>
+      <longname>MateConf audio sink</longname>
+      <class>Sink/Audio</class>
+      <description>Audio sink embedding the MateConf-settings for audio output</description>
+      <author>Jan Schmidt &lt;thaytan@mad.scientist.com&gt;</author>
+      <pads>
+      </pads>
+    </element>
+    <element>
+      <name>mateconfaudiosrc</name>
+      <longname>MateConf audio source</longname>
+      <class>Source/Audio</class>
+      <description>Audio source embedding the MateConf-settings for audio input</description>
+      <author>GStreamer maintainers &lt;gstreamer-devel@lists.sourceforge.net&gt;</author>
+      <pads>
+      </pads>
+    </element>
+    <element>
+      <name>mateconfvideosink</name>
+      <longname>MateConf video sink</longname>
+      <class>Sink/Video</class>
+      <description>Video sink embedding the MateConf-settings for video output</description>
+      <author>GStreamer maintainers &lt;gstreamer-devel@lists.sourceforge.net&gt;</author>
+      <pads>
+      </pads>
+    </element>
+    <element>
+      <name>mateconfvideosrc</name>
+      <longname>MateConf video source</longname>
+      <class>Source/Video</class>
+      <description>Video source embedding the MateConf-settings for video input</description>
+      <author>GStreamer maintainers &lt;gstreamer-devel@lists.sourceforge.net&gt;</author>
+      <pads>
+      </pads>
+    </element>
+  </elements>
+</plugin>
--- origsrc/gst-plugins-good-0.10.31/ext/Makefile.am	2011-12-11 12:48:10.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/Makefile.am	2012-04-18 02:48:04.000000000 -0500
@@ -82,6 +82,12 @@ else
 LIBPNG_DIR =
 endif
 
+if USE_MATECONF
+MATECONF_DIR = mateconf
+else
+MATECONF_DIR =
+endif
+
 # if USE_MIKMOD
 # MIKMOD_DIR = mikmod
 # else
@@ -147,6 +153,7 @@ SUBDIRS = \
 	$(LIBDV_DIR) \
 	$(LIBMNG_DIR) \
 	$(LIBPNG_DIR) \
+	$(MATECONF_DIR) \
 	$(MIKMOD_DIR) \
 	$(PULSE_DIR) \
 	$(SHOUT2_DIR) \
@@ -169,6 +176,7 @@ DIST_SUBDIRS = \
 	jpeg \
 	libcaca \
 	libpng \
+	mateconf \
 	pulse \
 	raw1394 \
 	shout2 \
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconf.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconf.c	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,304 @@
+/* GStreamer
+ * nf_get_default_audio_sink
+ * Copyright (C) <2002> Thomas Vander Stichele <thomas@apestaart.org>
+ * Copyright (C) <2006> Jürg Billeter <j@bitron.ch>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * this library handles interaction with MateConf
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+
+#include "gstmateconf.h"
+#include "gstmateconfelements.h"   /* for debug category */
+
+#ifndef GST_MATECONF_DIR
+#error "GST_MATECONF_DIR is not defined !"
+#endif
+
+static MateConfClient *_gst_mateconf_client = NULL;   /* MateConf connection */
+
+
+/* internal functions */
+
+static MateConfClient *
+gst_mateconf_get_client (void)
+{
+  if (!_gst_mateconf_client)
+    _gst_mateconf_client = mateconf_client_get_default ();
+
+  return _gst_mateconf_client;
+}
+
+/* external functions */
+
+/**
+ * gst_mateconf_get_string:
+ * @key: a #gchar corresponding to the key you want to get.
+ *
+ * Get MateConf key @key's string value.
+ *
+ * Returns: a newly allocated #gchar string containing @key's value,
+ * or NULL in the case of an error..
+ */
+gchar *
+gst_mateconf_get_string (const gchar * key)
+{
+  GError *error = NULL;
+  gchar *value = NULL;
+  gchar *full_key;
+
+  if (!g_str_has_prefix (key, GST_MATECONF_DIR))
+    full_key = g_strdup_printf ("%s/%s", GST_MATECONF_DIR, key);
+  else
+    full_key = g_strdup (key);
+
+  value = mateconf_client_get_string (gst_mateconf_get_client (), full_key, &error);
+  g_free (full_key);
+
+  if (error) {
+    g_warning ("gst_mateconf_get_string: error: %s\n", error->message);
+    g_error_free (error);
+    return NULL;
+  }
+
+  return value;
+}
+
+const gchar *
+gst_mateconf_get_key_for_sink_profile (GstMateConfProfile profile)
+{
+  switch (profile) {
+    case MATECONF_PROFILE_SOUNDS:
+      return GST_MATECONF_DIR "/" GST_MATECONF_AUDIOSINK_KEY;
+    case MATECONF_PROFILE_MUSIC:
+      return GST_MATECONF_DIR "/" GST_MATECONF_MUSIC_AUDIOSINK_KEY;
+    case MATECONF_PROFILE_CHAT:
+      return GST_MATECONF_DIR "/" GST_MATECONF_CHAT_AUDIOSINK_KEY;
+    default:
+      break;
+  }
+
+  g_return_val_if_reached (GST_MATECONF_DIR "/" GST_MATECONF_AUDIOSINK_KEY);
+}
+
+/**
+ * gst_mateconf_set_string:
+ * @key: a #gchar corresponding to the key you want to set.
+ * @value: a #gchar containing key value.
+ *
+ * Set MateConf key @key to string value @value.
+ */
+void
+gst_mateconf_set_string (const gchar * key, const gchar * value)
+{
+  GError *error = NULL;
+  gchar *full_key;
+
+  if (!g_str_has_prefix (key, GST_MATECONF_DIR))
+    full_key = g_strdup_printf ("%s/%s", GST_MATECONF_DIR, key);
+  else
+    full_key = g_strdup (key);
+
+  mateconf_client_set_string (gst_mateconf_get_client (), full_key, value, &error);
+  if (error) {
+    GST_ERROR ("gst_mateconf_set_string: error: %s\n", error->message);
+    g_error_free (error);
+  }
+  g_free (full_key);
+}
+
+/**
+ * gst_mateconf_render_bin_from_key:
+ * @key: a #gchar string corresponding to a MateConf key.
+ *
+ * Render bin from MateConf key @key.
+ *
+ * Returns: a #GstElement containing the rendered bin.
+ */
+GstElement *
+gst_mateconf_render_bin_from_key (const gchar * key)
+{
+  GstElement *bin = NULL;
+  gchar *value;
+
+  value = gst_mateconf_get_string (key);
+
+  GST_LOG ("%s = %s", GST_STR_NULL (key), GST_STR_NULL (value));
+
+  if (value) {
+    GError *err = NULL;
+
+    bin = gst_parse_bin_from_description (value, TRUE, &err);
+    if (err) {
+      GST_ERROR ("mateconf: error creating bin '%s': %s", value, err->message);
+      g_error_free (err);
+    }
+
+    g_free (value);
+  }
+  return bin;
+}
+
+/**
+ * gst_mateconf_render_bin_with_default:
+ * @bin: a #gchar string describing the pipeline to construct.
+ * @default_sink: an element to use as default if the given pipeline fails to construct.
+ *
+ * Render bin from description @bin using @default_sink element as a fallback.
+ *
+ * Returns: a #GstElement containing the rendered bin.
+ */
+GstElement *
+gst_mateconf_render_bin_with_default (const gchar * bin,
+    const gchar * default_sink)
+{
+  GstElement *ret = NULL;
+  GError *err = NULL;
+
+  if (bin != NULL)
+    ret = gst_parse_bin_from_description (bin, TRUE, &err);
+
+  if (ret == NULL || err != NULL) {
+    if (err) {
+      GST_DEBUG ("Could not create audio sink from MateConf settings: %s",
+          err->message);
+      g_error_free (err);
+    } else {
+      GST_DEBUG ("Could not create audio sink from MateConf settings");
+    }
+
+    ret = gst_element_factory_make (default_sink, NULL);
+
+    if (!ret)
+      g_warning
+          ("Could not build MateConf audio sink and the replacement %s doesn't work",
+          DEFAULT_AUDIOSINK);
+  }
+
+  return ret;
+}
+
+/**
+ * gst_mateconf_get_default_video_sink:
+ *
+ * Render video output bin from GStreamer MateConf key : "default/videosink".
+ * If key is invalid, the default video sink for the platform is used
+ * (typically xvimagesink or ximagesink).
+ *
+ * Returns: a #GstElement containing the video output bin, or NULL if
+ * everything failed.
+ */
+GstElement *
+gst_mateconf_get_default_video_sink (void)
+{
+  GstElement *ret = gst_mateconf_render_bin_from_key (GST_MATECONF_VIDEOSINK_KEY);
+
+  if (!ret) {
+    ret = gst_element_factory_make (DEFAULT_VIDEOSINK, NULL);
+
+    if (!ret)
+      g_warning ("No MateConf default video sink key and %s doesn't work",
+          DEFAULT_VIDEOSINK);
+  }
+
+  return ret;
+}
+
+/**
+ * gst_mateconf_get_default_audio_src:
+ *
+ * Render audio acquisition bin from GStreamer MateConf key : "default/audiosrc".
+ * If key is invalid, the default audio source for the plaform is used.
+ * (typically osssrc or sunaudiosrc).
+ *
+ * Returns: a #GstElement containing the audio source bin, or NULL if
+ * everything failed.
+ */
+GstElement *
+gst_mateconf_get_default_audio_src (void)
+{
+  GstElement *ret = gst_mateconf_render_bin_from_key (GST_MATECONF_AUDIOSRC_KEY);
+
+  if (!ret) {
+    ret = gst_element_factory_make (DEFAULT_AUDIOSRC, NULL);
+
+    if (!ret)
+      g_warning ("No MateConf default audio src key and %s doesn't work",
+          DEFAULT_AUDIOSRC);
+  }
+
+  return ret;
+}
+
+/**
+ * gst_mateconf_get_default_video_src:
+ *
+ * Render video acquisition bin from GStreamer MateConf key :
+ * "default/videosrc". If key is invalid, the default video source
+ * for the platform is used (typically videotestsrc).
+ *
+ * Returns: a #GstElement containing the video source bin, or NULL if
+ * everything failed.
+ */
+GstElement *
+gst_mateconf_get_default_video_src (void)
+{
+  GstElement *ret = gst_mateconf_render_bin_from_key (GST_MATECONF_VIDEOSRC_KEY);
+
+  if (!ret) {
+    ret = gst_element_factory_make (DEFAULT_VIDEOSRC, NULL);
+
+    if (!ret)
+      g_warning ("No MateConf default video src key and %s doesn't work",
+          DEFAULT_VIDEOSRC);
+  }
+
+  return ret;
+}
+
+/**
+ * gst_mateconf_get_default_visualization_element:
+ *
+ * Render visualization bin from GStreamer MateConf key : "default/visualization".
+ * If key is invalid, the default visualization element is used.
+ *
+ * Returns: a #GstElement containing the visualization bin, or NULL if
+ * everything failed.
+ */
+GstElement *
+gst_mateconf_get_default_visualization_element (void)
+{
+  GstElement *ret = gst_mateconf_render_bin_from_key ("default/visualization");
+
+  if (!ret) {
+    ret = gst_element_factory_make (DEFAULT_VISUALIZER, NULL);
+
+    if (!ret)
+      g_warning
+          ("No MateConf default visualization plugin key and %s doesn't work",
+          DEFAULT_VISUALIZER);
+  }
+
+  return ret;
+}
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconf.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconf.h	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,66 @@
+/* GStreamer
+ * Copyright (C) <2002> Thomas Vander Stichele <thomas@apestaart.org>
+ * Copyright (C) <2006> Jürg Billeter <j@bitron.ch>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GST_MATECONF_H
+#define GST_MATECONF_H
+
+/*
+ * this library handles interaction with MateConf
+ */
+
+#include <gst/gst.h>
+#include <mateconf/mateconf-client.h>
+
+G_BEGIN_DECLS
+
+#define GST_MATECONF_AUDIOSRC_KEY        "default/audiosrc"
+#define GST_MATECONF_AUDIOSINK_KEY       "default/audiosink"
+#define GST_MATECONF_MUSIC_AUDIOSINK_KEY "default/musicaudiosink"
+#define GST_MATECONF_CHAT_AUDIOSINK_KEY  "default/chataudiosink"
+#define GST_MATECONF_VIDEOSRC_KEY        "default/videosrc"
+#define GST_MATECONF_VIDEOSINK_KEY       "default/videosink"
+
+typedef enum
+{
+  MATECONF_PROFILE_SOUNDS,
+  MATECONF_PROFILE_MUSIC,
+  MATECONF_PROFILE_CHAT,
+  MATECONF_PROFILE_NONE /* Internal value only */
+} GstMateConfProfile;
+
+gchar *         gst_mateconf_get_string            (const gchar *key);
+void            gst_mateconf_set_string            (const gchar *key, 
+                                                 const gchar *value);
+
+const gchar *   gst_mateconf_get_key_for_sink_profile (GstMateConfProfile profile);
+
+GstElement *    gst_mateconf_render_bin_from_key           (const gchar *key);
+GstElement *    gst_mateconf_render_bin_with_default       (const gchar *bin,
+    const gchar *default_sink);
+
+GstElement *    gst_mateconf_get_default_video_sink (void);
+GstElement *    gst_mateconf_get_default_audio_sink (int profile);
+GstElement *    gst_mateconf_get_default_video_src (void);
+GstElement *    gst_mateconf_get_default_audio_src (void);
+GstElement *    gst_mateconf_get_default_visualization_element (void);
+
+G_END_DECLS
+
+#endif /* GST_MATECONF_H */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosink.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosink.c	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,310 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * (c) 2006 Jürg Billeter <j@bitron.ch>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-mateconfaudiosink
+ *
+ * This element outputs sound to the audiosink that has been configured in
+ * MateConf by the user.
+ * 
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch filesrc location=foo.ogg ! decodebin ! audioconvert ! audioresample ! mateconfaudiosink
+ * ]| Play on configured audiosink
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstmateconfelements.h"
+#include "gstmateconfaudiosink.h"
+
+static void gst_mateconf_audio_sink_dispose (GObject * object);
+static void gst_mateconf_audio_sink_finalize (GstMateConfAudioSink * sink);
+static void cb_change_child (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data);
+static GstStateChangeReturn
+gst_mateconf_audio_sink_change_state (GstElement * element,
+    GstStateChange transition);
+static void gst_mateconf_switch_profile (GstMateConfAudioSink * sink,
+    GstMateConfProfile profile);
+
+enum
+{
+  PROP_0,
+  PROP_PROFILE
+};
+
+GST_BOILERPLATE (GstMateConfAudioSink, gst_mateconf_audio_sink, GstSwitchSink,
+    GST_TYPE_SWITCH_SINK);
+
+static void gst_mateconf_audio_sink_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_mateconf_audio_sink_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static void
+gst_mateconf_audio_sink_base_init (gpointer klass)
+{
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  gst_element_class_set_details_simple (eklass, "MateConf audio sink",
+      "Sink/Audio",
+      "Audio sink embedding the MateConf-settings for audio output",
+      "Jan Schmidt <thaytan@mad.scientist.com>");
+}
+
+#define GST_TYPE_MATECONF_PROFILE (gst_mateconf_profile_get_type())
+static GType
+gst_mateconf_profile_get_type (void)
+{
+  static GType mateconf_profile_type = 0;
+  static const GEnumValue mateconf_profiles[] = {
+    {MATECONF_PROFILE_SOUNDS, "Sound Events", "sounds"},
+    {MATECONF_PROFILE_MUSIC, "Music and Movies", "music"},
+    {MATECONF_PROFILE_CHAT, "Audio/Video Conferencing", "chat"},
+    {0, NULL, NULL}
+  };
+
+  if (!mateconf_profile_type) {
+    mateconf_profile_type =
+        g_enum_register_static ("GstMateConfProfile", mateconf_profiles);
+  }
+  return mateconf_profile_type;
+}
+
+static void
+gst_mateconf_audio_sink_class_init (GstMateConfAudioSinkClass * klass)
+{
+  GObjectClass *oklass = G_OBJECT_CLASS (klass);
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  oklass->set_property = gst_mateconf_audio_sink_set_property;
+  oklass->get_property = gst_mateconf_audio_sink_get_property;
+  oklass->dispose = gst_mateconf_audio_sink_dispose;
+  oklass->finalize = (GObjectFinalizeFunc) gst_mateconf_audio_sink_finalize;
+  eklass->change_state = gst_mateconf_audio_sink_change_state;
+
+  g_object_class_install_property (oklass, PROP_PROFILE,
+      g_param_spec_enum ("profile", "Profile", "Profile",
+          GST_TYPE_MATECONF_PROFILE, MATECONF_PROFILE_SOUNDS,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+static void
+gst_mateconf_audio_sink_reset (GstMateConfAudioSink * sink)
+{
+  gst_switch_sink_set_child (GST_SWITCH_SINK (sink), NULL);
+
+  g_free (sink->mateconf_str);
+  sink->mateconf_str = NULL;
+}
+
+static void
+gst_mateconf_audio_sink_init (GstMateConfAudioSink * sink,
+    GstMateConfAudioSinkClass * g_class)
+{
+  gst_mateconf_audio_sink_reset (sink);
+
+  sink->client = mateconf_client_get_default ();
+  mateconf_client_add_dir (sink->client, GST_MATECONF_DIR "/default",
+      MATECONF_CLIENT_PRELOAD_RECURSIVE, NULL);
+
+  gst_mateconf_switch_profile (sink, MATECONF_PROFILE_SOUNDS);
+}
+
+static void
+gst_mateconf_audio_sink_dispose (GObject * object)
+{
+  GstMateConfAudioSink *sink = GST_MATECONF_AUDIO_SINK (object);
+
+  if (sink->client) {
+    gst_mateconf_switch_profile (sink, MATECONF_PROFILE_NONE);
+    g_object_unref (G_OBJECT (sink->client));
+    sink->client = NULL;
+  }
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static void
+gst_mateconf_audio_sink_finalize (GstMateConfAudioSink * sink)
+{
+  g_free (sink->mateconf_str);
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, finalize, ((GObject *) (sink)));
+}
+
+static gboolean
+do_change_child (GstMateConfAudioSink * sink)
+{
+  const gchar *key;
+  gchar *new_mateconf_str;
+  GstElement *new_kid;
+
+  if (sink->profile == MATECONF_PROFILE_NONE)
+    return FALSE;               /* Can't switch to a 'NONE' sink */
+
+  key = gst_mateconf_get_key_for_sink_profile (sink->profile);
+  new_mateconf_str = gst_mateconf_get_string (key);
+
+  GST_LOG_OBJECT (sink, "old mateconf string: %s", GST_STR_NULL (sink->mateconf_str));
+  GST_LOG_OBJECT (sink, "new mateconf string: %s", GST_STR_NULL (new_mateconf_str));
+
+  if (new_mateconf_str != NULL && sink->mateconf_str != NULL &&
+      (strlen (new_mateconf_str) == 0 ||
+          strcmp (sink->mateconf_str, new_mateconf_str) == 0)) {
+    g_free (new_mateconf_str);
+    GST_DEBUG_OBJECT (sink,
+        "MateConf key was updated, but it didn't change. Ignoring");
+    return TRUE;
+  }
+
+  GST_DEBUG_OBJECT (sink, "MateConf key changed: '%s' to '%s'",
+      GST_STR_NULL (sink->mateconf_str), GST_STR_NULL (new_mateconf_str));
+
+  GST_DEBUG_OBJECT (sink, "Creating new child for profile %d", sink->profile);
+  new_kid =
+      gst_mateconf_render_bin_with_default (new_mateconf_str, DEFAULT_AUDIOSINK);
+
+  if (new_kid == NULL) {
+    GST_ELEMENT_ERROR (sink, LIBRARY, SETTINGS, (NULL),
+        ("Failed to render audio sink from MateConf"));
+    goto fail;
+  }
+
+  if (!gst_switch_sink_set_child (GST_SWITCH_SINK (sink), new_kid)) {
+    GST_WARNING_OBJECT (sink, "Failed to update child element");
+    goto fail;
+  }
+
+  g_free (sink->mateconf_str);
+  sink->mateconf_str = new_mateconf_str;
+
+  GST_DEBUG_OBJECT (sink, "done changing mateconf audio sink");
+
+  return TRUE;
+
+fail:
+  g_free (new_mateconf_str);
+  return FALSE;
+}
+
+static void
+gst_mateconf_switch_profile (GstMateConfAudioSink * sink, GstMateConfProfile profile)
+{
+  if (sink->client == NULL)
+    return;
+
+  if (sink->notify_id) {
+    GST_DEBUG_OBJECT (sink, "Unsubscribing old key %s for profile %d",
+        gst_mateconf_get_key_for_sink_profile (sink->profile), sink->profile);
+    mateconf_client_notify_remove (sink->client, sink->notify_id);
+    sink->notify_id = 0;
+  }
+
+  sink->profile = profile;
+  if (profile != MATECONF_PROFILE_NONE) {
+    const gchar *key = gst_mateconf_get_key_for_sink_profile (sink->profile);
+
+    GST_DEBUG_OBJECT (sink, "Subscribing to key %s for profile %d",
+        key, profile);
+    sink->notify_id = mateconf_client_notify_add (sink->client, key,
+        cb_change_child, sink, NULL, NULL);
+  }
+}
+
+static void
+gst_mateconf_audio_sink_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstMateConfAudioSink *sink;
+
+  sink = GST_MATECONF_AUDIO_SINK (object);
+
+  switch (prop_id) {
+    case PROP_PROFILE:
+      gst_mateconf_switch_profile (sink, g_value_get_enum (value));
+      break;
+    default:
+      break;
+  }
+}
+
+static void
+gst_mateconf_audio_sink_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstMateConfAudioSink *sink;
+
+  sink = GST_MATECONF_AUDIO_SINK (object);
+
+  switch (prop_id) {
+    case PROP_PROFILE:
+      g_value_set_enum (value, sink->profile);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+cb_change_child (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data)
+{
+  do_change_child (GST_MATECONF_AUDIO_SINK (data));
+}
+
+static GstStateChangeReturn
+gst_mateconf_audio_sink_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstMateConfAudioSink *sink = GST_MATECONF_AUDIO_SINK (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!do_change_child (sink)) {
+        gst_mateconf_audio_sink_reset (sink);
+        return GST_STATE_CHANGE_FAILURE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_CALL_PARENT_WITH_DEFAULT (GST_ELEMENT_CLASS, change_state,
+      (element, transition), GST_STATE_CHANGE_SUCCESS);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      gst_mateconf_audio_sink_reset (sink);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosink.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosink.h	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,62 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_MATECONF_AUDIO_SINK_H__
+#define __GST_MATECONF_AUDIO_SINK_H__
+
+#include <gst/gst.h>
+#include <mateconf/mateconf-client.h>
+#include "gstswitchsink.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_MATECONF_AUDIO_SINK \
+  (gst_mateconf_audio_sink_get_type ())
+#define GST_MATECONF_AUDIO_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MATECONF_AUDIO_SINK, \
+                               GstMateConfAudioSink))
+#define GST_MATECONF_AUDIO_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MATECONF_AUDIO_SINK, \
+                            GstMateConfAudioSinkClass))
+#define GST_IS_MATECONF_AUDIO_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MATECONF_AUDIO_SINK))
+#define GST_IS_MATECONF_AUDIO_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MATECONF_AUDIO_SINK))
+
+typedef struct _GstMateConfAudioSink {
+  GstSwitchSink parent;
+
+  /* explicit pointers to stuff used */
+  MateConfClient *client;
+  GstMateConfProfile profile;
+  guint notify_id;
+
+  /* Current mateconf string */
+  gchar *mateconf_str;
+} GstMateConfAudioSink;
+
+typedef struct _GstMateConfAudioSinkClass {
+  GstSwitchSinkClass parent_class;
+} GstMateConfAudioSinkClass;
+
+GType   gst_mateconf_audio_sink_get_type   (void);
+
+G_END_DECLS
+
+#endif /* __GST_MATECONF_AUDIO_SINK_H__ */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosrc.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosrc.c	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,210 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * (c) 2005 Tim-Philipp Müller <tim centricular net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-mateconfaudiosrc
+ * @see_also: #GstAlsaSrc, #GstAutoAudioSrc
+ *
+ * This element records sound from the audiosink that has been configured in
+ * MateConf by the user.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch mateconfaudiosrc ! audioconvert ! wavenc ! filesink location=record.wav
+ * ]| Record from configured audioinput
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstmateconfelements.h"
+#include "gstmateconfaudiosrc.h"
+
+static void gst_mateconf_audio_src_dispose (GObject * object);
+static void gst_mateconf_audio_src_finalize (GstMateConfAudioSrc * src);
+static void cb_toggle_element (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data);
+static GstStateChangeReturn
+gst_mateconf_audio_src_change_state (GstElement * element,
+    GstStateChange transition);
+
+GST_BOILERPLATE (GstMateConfAudioSrc, gst_mateconf_audio_src, GstSwitchSrc,
+    GST_TYPE_SWITCH_SRC);
+
+static void
+gst_mateconf_audio_src_base_init (gpointer klass)
+{
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  gst_element_class_set_details_simple (eklass, "MateConf audio source",
+      "Source/Audio",
+      "Audio source embedding the MateConf-settings for audio input",
+      "GStreamer maintainers <gstreamer-devel@lists.sourceforge.net>");
+}
+
+static void
+gst_mateconf_audio_src_class_init (GstMateConfAudioSrcClass * klass)
+{
+  GObjectClass *oklass = G_OBJECT_CLASS (klass);
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  oklass->dispose = gst_mateconf_audio_src_dispose;
+  oklass->finalize = (GObjectFinalizeFunc) gst_mateconf_audio_src_finalize;
+  eklass->change_state = gst_mateconf_audio_src_change_state;
+}
+
+/*
+ * Hack to make negotiation work.
+ */
+
+static gboolean
+gst_mateconf_audio_src_reset (GstMateConfAudioSrc * src)
+{
+  gst_switch_src_set_child (GST_SWITCH_SRC (src), NULL);
+
+  g_free (src->mateconf_str);
+  src->mateconf_str = NULL;
+  return TRUE;
+}
+
+static void
+gst_mateconf_audio_src_init (GstMateConfAudioSrc * src,
+    GstMateConfAudioSrcClass * g_class)
+{
+  gst_mateconf_audio_src_reset (src);
+
+  src->client = mateconf_client_get_default ();
+  mateconf_client_add_dir (src->client, GST_MATECONF_DIR,
+      MATECONF_CLIENT_PRELOAD_RECURSIVE, NULL);
+  src->mateconf_notify_id = mateconf_client_notify_add (src->client,
+      GST_MATECONF_DIR "/" GST_MATECONF_AUDIOSRC_KEY,
+      cb_toggle_element, src, NULL, NULL);
+}
+
+static void
+gst_mateconf_audio_src_dispose (GObject * object)
+{
+  GstMateConfAudioSrc *src = GST_MATECONF_AUDIO_SRC (object);
+
+  if (src->client) {
+    if (src->mateconf_notify_id) {
+      mateconf_client_notify_remove (src->client, src->mateconf_notify_id);
+      src->mateconf_notify_id = 0;
+    }
+
+    g_object_unref (G_OBJECT (src->client));
+    src->client = NULL;
+  }
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static void
+gst_mateconf_audio_src_finalize (GstMateConfAudioSrc * src)
+{
+  g_free (src->mateconf_str);
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, finalize, ((GObject *) (src)));
+}
+
+static gboolean
+do_toggle_element (GstMateConfAudioSrc * src)
+{
+  GstElement *new_kid;
+  gchar *new_mateconf_str;
+
+  new_mateconf_str = gst_mateconf_get_string (GST_MATECONF_AUDIOSRC_KEY);
+  if (new_mateconf_str != NULL && src->mateconf_str != NULL &&
+      (strlen (new_mateconf_str) == 0 ||
+          strcmp (src->mateconf_str, new_mateconf_str) == 0)) {
+    g_free (new_mateconf_str);
+    GST_DEBUG_OBJECT (src, "MateConf key was updated, but it didn't change");
+    return TRUE;
+  }
+
+  GST_DEBUG_OBJECT (src, "MateConf key changed: '%s' to '%s'",
+      GST_STR_NULL (src->mateconf_str), GST_STR_NULL (new_mateconf_str));
+
+  GST_DEBUG_OBJECT (src, "Creating new kid");
+  if (!(new_kid = gst_mateconf_get_default_audio_src ())) {
+    GST_ELEMENT_ERROR (src, LIBRARY, SETTINGS, (NULL),
+        ("Failed to render audio src from MateConf"));
+    return FALSE;
+  }
+
+  if (!gst_switch_src_set_child (GST_SWITCH_SRC (src), new_kid)) {
+    GST_WARNING_OBJECT (src, "Failed to update child element");
+    goto fail;
+  }
+
+  g_free (src->mateconf_str);
+  src->mateconf_str = new_mateconf_str;
+
+  GST_DEBUG_OBJECT (src, "done changing mateconf audio src");
+
+  return TRUE;
+fail:
+  g_free (new_mateconf_str);
+  return FALSE;
+}
+
+static void
+cb_toggle_element (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data)
+{
+  do_toggle_element (GST_MATECONF_AUDIO_SRC (data));
+}
+
+static GstStateChangeReturn
+gst_mateconf_audio_src_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstMateConfAudioSrc *src = GST_MATECONF_AUDIO_SRC (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!do_toggle_element (src)) {
+        gst_mateconf_audio_src_reset (src);
+        return GST_STATE_CHANGE_FAILURE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_CALL_PARENT_WITH_DEFAULT (GST_ELEMENT_CLASS, change_state,
+      (element, transition), GST_STATE_CHANGE_SUCCESS);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      if (!gst_mateconf_audio_src_reset (src))
+        ret = GST_STATE_CHANGE_FAILURE;
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosrc.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfaudiosrc.h	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,57 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * (c) 2005 Tim-Philipp Müller <tim centricular net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_MATECONF_AUDIO_SRC_H__
+#define __GST_MATECONF_AUDIO_SRC_H__
+
+#include <gst/gst.h>
+#include <mateconf/mateconf-client.h>
+
+#include "gstswitchsrc.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_MATECONF_AUDIO_SRC            (gst_mateconf_audio_src_get_type ())
+#define GST_MATECONF_AUDIO_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MATECONF_AUDIO_SRC, GstMateConfAudioSrc))
+#define GST_MATECONF_AUDIO_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MATECONF_AUDIO_SRC, GstMateConfAudioSrcClass))
+#define GST_IS_MATECONF_AUDIO_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MATECONF_AUDIO_SRC))
+#define GST_IS_MATECONF_AUDIO_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MATECONF_AUDIO_SRC))
+
+typedef struct _GstMateConfAudioSrc {
+  GstSwitchSrc parent;
+
+  /* explicit pointers to stuff used */
+  MateConfClient *client;
+
+  guint mateconf_notify_id;
+
+  /* Current mateconf string */
+  gchar *mateconf_str;
+} GstMateConfAudioSrc;
+
+typedef struct _GstMateConfAudioSrcClass {
+  GstSwitchSrcClass parent_class;
+} GstMateConfAudioSrcClass;
+
+GType   gst_mateconf_audio_src_get_type   (void);
+
+G_END_DECLS
+
+#endif /* __GST_MATECONF_AUDIO_SRC_H__ */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfelements.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfelements.c	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,59 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+
+#include "gstmateconfelements.h"
+
+#include "gstmateconfaudiosink.h"
+#include "gstmateconfaudiosrc.h"
+#include "gstmateconfvideosink.h"
+#include "gstmateconfvideosrc.h"
+
+GST_DEBUG_CATEGORY (mateconf_debug);
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (mateconf_debug, "mateconf", 0,
+      "MateConf/GStreamer audio/video output wrapper elements");
+
+  if (!gst_element_register (plugin, "mateconfvideosink",
+          GST_RANK_NONE, GST_TYPE_MATECONF_VIDEO_SINK) ||
+      !gst_element_register (plugin, "mateconfvideosrc",
+          GST_RANK_NONE, GST_TYPE_MATECONF_VIDEO_SRC) ||
+      !gst_element_register (plugin, "mateconfaudiosink",
+          GST_RANK_NONE, GST_TYPE_MATECONF_AUDIO_SINK) ||
+      !gst_element_register (plugin, "mateconfaudiosrc",
+          GST_RANK_NONE, GST_TYPE_MATECONF_AUDIO_SRC)) {
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "mateconfelements",
+    "elements wrapping the GStreamer/MateConf audio/video output settings",
+    plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfelements.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfelements.h	2012-04-18 02:48:04.000000000 -0500
@@ -0,0 +1,28 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_MATECONF_ELEMENTS_H__
+#define __GST_MATECONF_ELEMENTS_H__
+
+#include "gstmateconf.h"
+
+GST_DEBUG_CATEGORY_EXTERN (mateconf_debug);
+#define GST_CAT_DEFAULT mateconf_debug
+
+#endif /* __GST_MATECONF_ELEMENTS_H__ */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosink.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosink.c	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,210 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-mateconfvideosink
+ *
+ * This element outputs video to the videosink that has been configured in
+ * MateConf by the user.
+ * 
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch filesrc location=foo.ogg ! decodebin ! ffmpegcolorspace ! mateconfvideosink
+ * ]| Play on configured videosink
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstmateconfelements.h"
+#include "gstmateconfvideosink.h"
+
+static void gst_mateconf_video_sink_dispose (GObject * object);
+static void gst_mateconf_video_sink_finalize (GstMateConfVideoSink * sink);
+static void cb_toggle_element (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data);
+static GstStateChangeReturn
+gst_mateconf_video_sink_change_state (GstElement * element,
+    GstStateChange transition);
+
+GST_BOILERPLATE (GstMateConfVideoSink, gst_mateconf_video_sink, GstSwitchSink,
+    GST_TYPE_SWITCH_SINK);
+
+static void
+gst_mateconf_video_sink_base_init (gpointer klass)
+{
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  gst_element_class_set_details_simple (eklass, "MateConf video sink",
+      "Sink/Video",
+      "Video sink embedding the MateConf-settings for video output",
+      "GStreamer maintainers <gstreamer-devel@lists.sourceforge.net>");
+}
+
+static void
+gst_mateconf_video_sink_class_init (GstMateConfVideoSinkClass * klass)
+{
+  GObjectClass *oklass = G_OBJECT_CLASS (klass);
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  oklass->dispose = gst_mateconf_video_sink_dispose;
+  oklass->finalize = (GObjectFinalizeFunc) gst_mateconf_video_sink_finalize;
+  eklass->change_state = gst_mateconf_video_sink_change_state;
+}
+
+/*
+ * Hack to make negotiation work.
+ */
+
+static void
+gst_mateconf_video_sink_reset (GstMateConfVideoSink * sink)
+{
+  gst_switch_sink_set_child (GST_SWITCH_SINK (sink), NULL);
+
+  g_free (sink->mateconf_str);
+  sink->mateconf_str = NULL;
+}
+
+static void
+gst_mateconf_video_sink_init (GstMateConfVideoSink * sink,
+    GstMateConfVideoSinkClass * g_class)
+{
+  gst_mateconf_video_sink_reset (sink);
+
+  sink->client = mateconf_client_get_default ();
+  mateconf_client_add_dir (sink->client, GST_MATECONF_DIR,
+      MATECONF_CLIENT_PRELOAD_RECURSIVE, NULL);
+  sink->notify_id = mateconf_client_notify_add (sink->client,
+      GST_MATECONF_DIR "/" GST_MATECONF_VIDEOSINK_KEY,
+      cb_toggle_element, sink, NULL, NULL);
+}
+
+static void
+gst_mateconf_video_sink_dispose (GObject * object)
+{
+  GstMateConfVideoSink *sink = GST_MATECONF_VIDEO_SINK (object);
+
+  if (sink->client) {
+    if (sink->notify_id != 0)
+      mateconf_client_notify_remove (sink->client, sink->notify_id);
+
+    g_object_unref (G_OBJECT (sink->client));
+    sink->client = NULL;
+  }
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static void
+gst_mateconf_video_sink_finalize (GstMateConfVideoSink * sink)
+{
+  g_free (sink->mateconf_str);
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, finalize, ((GObject *) (sink)));
+}
+
+static gboolean
+do_change_child (GstMateConfVideoSink * sink)
+{
+  gchar *new_mateconf_str;
+  GstElement *new_kid;
+
+  new_mateconf_str = gst_mateconf_get_string (GST_MATECONF_VIDEOSINK_KEY);
+
+  GST_LOG_OBJECT (sink, "old mateconf string: %s", GST_STR_NULL (sink->mateconf_str));
+  GST_LOG_OBJECT (sink, "new mateconf string: %s", GST_STR_NULL (new_mateconf_str));
+
+  if (new_mateconf_str != NULL && sink->mateconf_str != NULL &&
+      (strlen (new_mateconf_str) == 0 ||
+          strcmp (sink->mateconf_str, new_mateconf_str) == 0)) {
+    g_free (new_mateconf_str);
+    GST_DEBUG_OBJECT (sink,
+        "MateConf key was updated, but it didn't change. Ignoring");
+    return TRUE;
+  }
+
+  GST_DEBUG_OBJECT (sink, "MateConf key changed: '%s' to '%s'",
+      GST_STR_NULL (sink->mateconf_str), GST_STR_NULL (new_mateconf_str));
+
+  GST_DEBUG_OBJECT (sink, "Creating new kid");
+  if (!(new_kid = gst_mateconf_get_default_video_sink ())) {
+    GST_ELEMENT_ERROR (sink, LIBRARY, SETTINGS, (NULL),
+        ("Failed to render video sink from MateConf"));
+    return FALSE;
+  }
+
+  if (!gst_switch_sink_set_child (GST_SWITCH_SINK (sink), new_kid)) {
+    GST_WARNING_OBJECT (sink, "Failed to update child element");
+    goto fail;
+  }
+
+  g_free (sink->mateconf_str);
+  sink->mateconf_str = new_mateconf_str;
+
+  GST_DEBUG_OBJECT (sink, "done changing mateconf video sink");
+
+  return TRUE;
+
+fail:
+  g_free (new_mateconf_str);
+  return FALSE;
+}
+
+static void
+cb_toggle_element (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data)
+{
+  do_change_child (GST_MATECONF_VIDEO_SINK (data));
+}
+
+static GstStateChangeReturn
+gst_mateconf_video_sink_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstMateConfVideoSink *sink = GST_MATECONF_VIDEO_SINK (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!do_change_child (sink)) {
+        gst_mateconf_video_sink_reset (sink);
+        return GST_STATE_CHANGE_FAILURE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_CALL_PARENT_WITH_DEFAULT (GST_ELEMENT_CLASS, change_state,
+      (element, transition), GST_STATE_CHANGE_SUCCESS);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      gst_mateconf_video_sink_reset (sink);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosink.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosink.h	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,64 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_MATECONF_VIDEO_SINK_H__
+#define __GST_MATECONF_VIDEO_SINK_H__
+
+#include <gst/gst.h>
+#include <mateconf/mateconf-client.h>
+
+#include "gstswitchsink.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_MATECONF_VIDEO_SINK \
+  (gst_mateconf_video_sink_get_type ())
+#define GST_MATECONF_VIDEO_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MATECONF_VIDEO_SINK, \
+                               GstMateConfVideoSink))
+#define GST_MATECONF_VIDEO_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MATECONF_VIDEO_SINK, \
+                            GstMateConfVideoSinkClass))
+#define GST_IS_MATECONF_VIDEO_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MATECONF_VIDEO_SINK))
+#define GST_IS_MATECONF_VIDEO_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MATECONF_VIDEO_SINK))
+
+typedef struct _GstMateConfVideoSink {
+  GstSwitchSink parent;
+
+  /* explicit pointers to stuff used */
+  MateConfClient *client;
+
+  /* mateconf notify id */
+  guint notify_id;
+
+  /* Current mateconf string */
+  gchar *mateconf_str;
+} GstMateConfVideoSink;
+
+typedef struct _GstMateConfVideoSinkClass {
+  GstSwitchSinkClass parent_class;
+} GstMateConfVideoSinkClass;
+
+GType   gst_mateconf_video_sink_get_type   (void);
+
+G_END_DECLS
+
+#endif /* __GST_MATECONF_VIDEO_SINK_H__ */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosrc.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosrc.c	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,209 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * (c) 2005 Tim-Philipp Müller <tim centricular net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-mateconfvideosrc
+ * @see_also: #GstAlsaSrc, #GstAutoVideoSrc
+ *
+ * This element records video from the videosink that has been configured in
+ * MateConf by the user.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch mateconfvideosrc ! theoraenc ! oggmux ! filesink location=record.ogg
+ * ]| Record from configured videoinput
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstmateconfelements.h"
+#include "gstmateconfvideosrc.h"
+
+static void gst_mateconf_video_src_dispose (GObject * object);
+static void gst_mateconf_video_src_finalize (GstMateConfVideoSrc * src);
+static void cb_toggle_element (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data);
+static GstStateChangeReturn
+gst_mateconf_video_src_change_state (GstElement * element,
+    GstStateChange transition);
+
+GST_BOILERPLATE (GstMateConfVideoSrc, gst_mateconf_video_src, GstSwitchSrc,
+    GST_TYPE_SWITCH_SRC);
+
+static void
+gst_mateconf_video_src_base_init (gpointer klass)
+{
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  gst_element_class_set_details_simple (eklass, "MateConf video source",
+      "Source/Video",
+      "Video source embedding the MateConf-settings for video input",
+      "GStreamer maintainers <gstreamer-devel@lists.sourceforge.net>");
+}
+
+static void
+gst_mateconf_video_src_class_init (GstMateConfVideoSrcClass * klass)
+{
+  GObjectClass *oklass = G_OBJECT_CLASS (klass);
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+
+  oklass->dispose = gst_mateconf_video_src_dispose;
+  oklass->finalize = (GObjectFinalizeFunc) gst_mateconf_video_src_finalize;
+  eklass->change_state = gst_mateconf_video_src_change_state;
+}
+
+/*
+ * Hack to make negotiation work.
+ */
+
+static gboolean
+gst_mateconf_video_src_reset (GstMateConfVideoSrc * src)
+{
+  gst_switch_src_set_child (GST_SWITCH_SRC (src), NULL);
+
+  g_free (src->mateconf_str);
+  src->mateconf_str = NULL;
+
+  return TRUE;
+}
+
+static void
+gst_mateconf_video_src_init (GstMateConfVideoSrc * src,
+    GstMateConfVideoSrcClass * g_class)
+{
+  gst_mateconf_video_src_reset (src);
+
+  src->client = mateconf_client_get_default ();
+  mateconf_client_add_dir (src->client, GST_MATECONF_DIR,
+      MATECONF_CLIENT_PRELOAD_RECURSIVE, NULL);
+  src->notify_id = mateconf_client_notify_add (src->client,
+      GST_MATECONF_DIR "/" GST_MATECONF_VIDEOSRC_KEY,
+      cb_toggle_element, src, NULL, NULL);
+}
+
+static void
+gst_mateconf_video_src_dispose (GObject * object)
+{
+  GstMateConfVideoSrc *src = GST_MATECONF_VIDEO_SRC (object);
+
+  if (src->client) {
+    if (src->notify_id != 0)
+      mateconf_client_notify_remove (src->client, src->notify_id);
+
+    g_object_unref (G_OBJECT (src->client));
+    src->client = NULL;
+  }
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static void
+gst_mateconf_video_src_finalize (GstMateConfVideoSrc * src)
+{
+  g_free (src->mateconf_str);
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, finalize, ((GObject *) (src)));
+}
+
+static gboolean
+do_toggle_element (GstMateConfVideoSrc * src)
+{
+  GstElement *new_kid;
+  gchar *new_mateconf_str;
+
+  new_mateconf_str = gst_mateconf_get_string (GST_MATECONF_VIDEOSRC_KEY);
+  if (new_mateconf_str != NULL && src->mateconf_str != NULL &&
+      (strlen (new_mateconf_str) == 0 ||
+          strcmp (src->mateconf_str, new_mateconf_str) == 0)) {
+    g_free (new_mateconf_str);
+    GST_DEBUG_OBJECT (src, "MateConf key was updated, but it didn't change");
+    return TRUE;
+  }
+
+  GST_DEBUG_OBJECT (src, "MateConf key changed: '%s' to '%s'",
+      GST_STR_NULL (src->mateconf_str), GST_STR_NULL (new_mateconf_str));
+
+  GST_DEBUG_OBJECT (src, "Creating new kid");
+  if (!(new_kid = gst_mateconf_get_default_video_src ())) {
+    GST_ELEMENT_ERROR (src, LIBRARY, SETTINGS, (NULL),
+        ("Failed to render video src from MateConf"));
+    return FALSE;
+  }
+
+  if (!gst_switch_src_set_child (GST_SWITCH_SRC (src), new_kid)) {
+    GST_WARNING_OBJECT (src, "Failed to update child element");
+    goto fail;
+  }
+
+  g_free (src->mateconf_str);
+  src->mateconf_str = new_mateconf_str;
+
+  GST_DEBUG_OBJECT (src, "done changing mateconf video src");
+
+  return TRUE;
+fail:
+  g_free (new_mateconf_str);
+  return FALSE;
+}
+
+static void
+cb_toggle_element (MateConfClient * client,
+    guint connection_id, MateConfEntry * entry, gpointer data)
+{
+  do_toggle_element (GST_MATECONF_VIDEO_SRC (data));
+}
+
+static GstStateChangeReturn
+gst_mateconf_video_src_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstMateConfVideoSrc *src = GST_MATECONF_VIDEO_SRC (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!do_toggle_element (src)) {
+        gst_mateconf_video_src_reset (src);
+        return GST_STATE_CHANGE_FAILURE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_CALL_PARENT_WITH_DEFAULT (GST_ELEMENT_CLASS, change_state,
+      (element, transition), GST_STATE_CHANGE_SUCCESS);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      if (!gst_mateconf_video_src_reset (src))
+        ret = GST_STATE_CHANGE_FAILURE;
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosrc.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstmateconfvideosrc.h	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,58 @@
+/* GStreamer
+ * (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * (c) 2005 Tim-Philipp Müller <tim centricular net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_MATECONF_VIDEO_SRC_H__
+#define __GST_MATECONF_VIDEO_SRC_H__
+
+#include <gst/gst.h>
+#include <mateconf/mateconf-client.h>
+
+#include "gstswitchsrc.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_MATECONF_VIDEO_SRC            (gst_mateconf_video_src_get_type ())
+#define GST_MATECONF_VIDEO_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MATECONF_VIDEO_SRC, GstMateConfVideoSrc))
+#define GST_MATECONF_VIDEO_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MATECONF_VIDEO_SRC, GstMateConfVideoSrcClass))
+#define GST_IS_MATECONF_VIDEO_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MATECONF_VIDEO_SRC))
+#define GST_IS_MATECONF_VIDEO_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MATECONF_VIDEO_SRC))
+
+typedef struct _GstMateConfVideoSrc {
+  GstSwitchSrc parent;
+
+  /* explicit pointers to stuff used */
+  MateConfClient *client;
+
+  /* mateconf key notification id */
+  guint notify_id;
+
+  /* Current mateconf string */
+  gchar *mateconf_str;
+} GstMateConfVideoSrc;
+
+typedef struct _GstMateConfVideoSrcClass {
+  GstSwitchSrcClass parent_class;
+} GstMateConfVideoSrcClass;
+
+GType   gst_mateconf_video_src_get_type   (void);
+
+G_END_DECLS
+
+#endif /* __GST_MATECONF_VIDEO_SRC_H__ */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsink.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsink.c	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,269 @@
+/* GStreamer
+ * Copyright (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * Copyright (c) 2006 Jürg Billeter <j@bitron.ch>
+ * Copyright (c) 2007 Jan Schmidt <thaytan@noraisin.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstswitchsink.h"
+
+GST_DEBUG_CATEGORY_STATIC (switch_debug);
+#define GST_CAT_DEFAULT switch_debug
+
+static void gst_switch_sink_dispose (GObject * object);
+static GstStateChangeReturn
+gst_switch_sink_change_state (GstElement * element, GstStateChange transition);
+
+enum
+{
+  PROP_0
+};
+
+GST_BOILERPLATE (GstSwitchSink, gst_switch_sink, GstBin, GST_TYPE_BIN);
+
+static void
+gst_switch_sink_base_init (gpointer klass)
+{
+  GST_DEBUG_CATEGORY_INIT (switch_debug, "switchsink", 0, "switchsink element");
+}
+
+static void
+gst_switch_sink_class_init (GstSwitchSinkClass * klass)
+{
+  GObjectClass *oklass = G_OBJECT_CLASS (klass);
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+  static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+      GST_PAD_SINK,
+      GST_PAD_ALWAYS,
+      GST_STATIC_CAPS_ANY);
+  GstPadTemplate *child_pad_templ;
+
+  oklass->dispose = gst_switch_sink_dispose;
+  eklass->change_state = gst_switch_sink_change_state;
+
+  /* Provide a default pad template if the child didn't */
+  child_pad_templ = gst_element_class_get_pad_template (eklass, "sink");
+  if (child_pad_templ == NULL) {
+    gst_element_class_add_static_pad_template (eklass, &sink_template);
+  }
+}
+
+static gboolean
+gst_switch_sink_reset (GstSwitchSink * sink)
+{
+  /* this will install fakesink if no other child has been set,
+   * otherwise we rely on the subclass to know when to unset its
+   * custom kid */
+  if (sink->kid == NULL) {
+    return gst_switch_sink_set_child (sink, NULL);
+  }
+
+  return TRUE;
+}
+
+static void
+gst_switch_sink_init (GstSwitchSink * sink, GstSwitchSinkClass * g_class)
+{
+  GstElementClass *eklass = GST_ELEMENT_GET_CLASS (sink);
+  GstPadTemplate *templ;
+
+  templ = gst_element_class_get_pad_template (eklass, "sink");
+  sink->pad = gst_ghost_pad_new_no_target_from_template ("sink", templ);
+  gst_element_add_pad (GST_ELEMENT (sink), sink->pad);
+
+  gst_switch_sink_reset (sink);
+
+  GST_OBJECT_FLAG_SET (sink, GST_ELEMENT_IS_SINK);
+}
+
+static void
+gst_switch_sink_dispose (GObject * object)
+{
+  GstSwitchSink *sink = GST_SWITCH_SINK (object);
+  GstObject *new_kid, *kid;
+
+  GST_OBJECT_LOCK (sink);
+  new_kid = GST_OBJECT_CAST (sink->new_kid);
+  sink->new_kid = NULL;
+
+  kid = GST_OBJECT_CAST (sink->kid);
+  sink->kid = NULL;
+  GST_OBJECT_UNLOCK (sink);
+
+  gst_object_replace (&new_kid, NULL);
+  gst_object_replace (&kid, NULL);
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static gboolean
+gst_switch_sink_commit_new_kid (GstSwitchSink * sink)
+{
+  GstPad *targetpad;
+  GstState kid_state;
+  GstElement *new_kid, *old_kid;
+  gboolean is_fakesink = FALSE;
+  GstBus *bus;
+
+  /* need locking around member accesses */
+  GST_OBJECT_LOCK (sink);
+  /* If we're currently changing state, set the child to the next state
+   * we're transitioning too, rather than our current state which is 
+   * about to change */
+  if (GST_STATE_NEXT (sink) != GST_STATE_VOID_PENDING)
+    kid_state = GST_STATE_NEXT (sink);
+  else
+    kid_state = GST_STATE (sink);
+
+  new_kid = sink->new_kid ? gst_object_ref (sink->new_kid) : NULL;
+  sink->new_kid = NULL;
+  GST_OBJECT_UNLOCK (sink);
+
+  /* Fakesink by default if NULL is passed as the new child */
+  if (new_kid == NULL) {
+    GST_DEBUG_OBJECT (sink, "Replacing kid with fakesink");
+    new_kid = gst_element_factory_make ("fakesink", "testsink");
+    if (new_kid == NULL) {
+      GST_ERROR_OBJECT (sink, "Failed to create fakesink");
+      return FALSE;
+    }
+    /* Add a reference, as it would if the element came from sink->new_kid */
+    gst_object_ref (new_kid);
+    g_object_set (new_kid, "sync", TRUE, NULL);
+    is_fakesink = TRUE;
+  } else {
+    GST_DEBUG_OBJECT (sink, "Setting new kid");
+  }
+
+  /* set temporary bus of our own to catch error messages from the child
+   * (could we just set our own bus on it, or would the state change messages
+   * from the not-yet-added element confuse the state change algorithm? Let's
+   * play it safe for now) */
+  bus = gst_bus_new ();
+  gst_element_set_bus (new_kid, bus);
+  gst_object_unref (bus);
+
+  if (gst_element_set_state (new_kid, kid_state) == GST_STATE_CHANGE_FAILURE) {
+    GstMessage *msg;
+
+    /* check if child posted an error message and if so re-post it on our bus
+     * so that the application gets to see a decent error and not our generic
+     * fallback error message which is completely indecipherable to the user */
+    msg = gst_bus_pop_filtered (GST_ELEMENT_BUS (new_kid), GST_MESSAGE_ERROR);
+    if (msg) {
+      GST_INFO_OBJECT (sink, "Forwarding kid error: %" GST_PTR_FORMAT, msg);
+      gst_element_post_message (GST_ELEMENT (sink), msg);
+    }
+    GST_ELEMENT_ERROR (sink, CORE, STATE_CHANGE, (NULL),
+        ("Failed to set state on new child."));
+    gst_element_set_bus (new_kid, NULL);
+    gst_object_unref (new_kid);
+    return FALSE;
+  }
+  gst_element_set_bus (new_kid, NULL);
+  gst_bin_add (GST_BIN (sink), new_kid);
+
+  /* Now, replace the existing child */
+  GST_OBJECT_LOCK (sink);
+  old_kid = sink->kid;
+  sink->kid = new_kid;
+  /* Mark whether a custom kid or fakesink has been installed */
+  sink->have_kid = !is_fakesink;
+  GST_OBJECT_UNLOCK (sink);
+
+  /* kill old element */
+  if (old_kid) {
+    GST_DEBUG_OBJECT (sink, "Removing old kid %" GST_PTR_FORMAT, old_kid);
+    gst_element_set_state (old_kid, GST_STATE_NULL);
+    gst_bin_remove (GST_BIN (sink), old_kid);
+    gst_object_unref (old_kid);
+    /* Don't lose the SINK flag */
+    GST_OBJECT_FLAG_SET (sink, GST_ELEMENT_IS_SINK);
+  }
+
+  /* re-attach ghostpad */
+  GST_DEBUG_OBJECT (sink, "Creating new ghostpad");
+  targetpad = gst_element_get_static_pad (sink->kid, "sink");
+  gst_ghost_pad_set_target (GST_GHOST_PAD (sink->pad), targetpad);
+  gst_object_unref (targetpad);
+  GST_DEBUG_OBJECT (sink, "done changing child of switchsink");
+
+  /* FIXME: Push new-segment info and pre-roll buffer(s) into the kid */
+
+  return TRUE;
+}
+
+gboolean
+gst_switch_sink_set_child (GstSwitchSink * sink, GstElement * new_kid)
+{
+  GstState cur, next;
+  GstElement **p_kid;
+
+  /* Nothing to do if clearing the child and we've already installed fakesink */
+  if (new_kid == NULL && sink->kid != NULL && sink->have_kid == FALSE)
+    return TRUE;
+
+  /* Store the new kid to be committed later */
+  GST_OBJECT_LOCK (sink);
+  cur = GST_STATE (sink);
+  next = GST_STATE_NEXT (sink);
+  p_kid = &sink->new_kid;
+  gst_object_replace ((GstObject **) p_kid, (GstObject *) new_kid);
+  GST_OBJECT_UNLOCK (sink);
+  if (new_kid)
+    gst_object_unref (new_kid);
+
+  /* Sometime, it would be lovely to allow sink changes even when
+   * already running, but this involves sending an appropriate new-segment
+   * and possibly prerolling etc */
+  /* FIXME: Block the pad and replace the kid when it completes */
+  if (cur > GST_STATE_READY || next == GST_STATE_PAUSED) {
+    GST_DEBUG_OBJECT (sink,
+        "Switch-sink is already running. Ignoring change of child.");
+    gst_object_unref (new_kid);
+    return TRUE;
+  }
+
+  return gst_switch_sink_commit_new_kid (sink);
+}
+
+static GstStateChangeReturn
+gst_switch_sink_change_state (GstElement * element, GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstSwitchSink *sink = GST_SWITCH_SINK (element);
+
+  ret = GST_CALL_PARENT_WITH_DEFAULT (GST_ELEMENT_CLASS, change_state,
+      (element, transition), GST_STATE_CHANGE_SUCCESS);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      if (!gst_switch_sink_reset (sink))
+        ret = GST_STATE_CHANGE_FAILURE;
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsink.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsink.h	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,62 @@
+/* GStreamer
+ * Copyright (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * Copyright (c) 2007 Jan Schmidt <thaytan@mad.scientist.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_SWITCH_SINK_H__
+#define __GST_SWITCH_SINK_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SWITCH_SINK \
+  (gst_switch_sink_get_type ())
+#define GST_SWITCH_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SWITCH_SINK, \
+                               GstSwitchSink))
+#define GST_SWITCH_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SWITCH_SINK, \
+                            GstSwitchSinkClass))
+#define GST_IS_SWITCH_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SWITCH_SINK))
+#define GST_IS_SWITCH_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SWITCH_SINK))
+
+typedef struct _GstSwitchSink {
+  GstBin parent;
+
+  GstElement *kid;
+  GstElement *new_kid;
+  GstPad *pad;
+
+  /* If a custom child has been set... */
+  gboolean have_kid;
+} GstSwitchSink;
+
+typedef struct _GstSwitchSinkClass {
+  GstBinClass parent_class;
+} GstSwitchSinkClass;
+
+GType   gst_switch_sink_get_type   (void);
+
+gboolean gst_switch_sink_set_child (GstSwitchSink *ssink, GstElement *new_kid);
+
+G_END_DECLS
+
+#endif /* __GST_SWITCH_SINK_H__ */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsrc.c	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsrc.c	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,261 @@
+/* GStreamer
+ * Copyright (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * Copyright (c) 2006 Jürg Billeter <j@bitron.ch>
+ * Copyright (c) 2007 Jan Schmidt <thaytan@noraisin.net>
+ * Copyright (c) 2010 Sebastian Dröge <sebastian.droege@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstswitchsrc.h"
+
+GST_DEBUG_CATEGORY_STATIC (switch_debug);
+#define GST_CAT_DEFAULT switch_debug
+
+static void gst_switch_src_dispose (GObject * object);
+static GstStateChangeReturn
+gst_switch_src_change_state (GstElement * element, GstStateChange transition);
+
+GST_BOILERPLATE (GstSwitchSrc, gst_switch_src, GstBin, GST_TYPE_BIN);
+
+static void
+gst_switch_src_base_init (gpointer klass)
+{
+  GST_DEBUG_CATEGORY_INIT (switch_debug, "switchsrc", 0, "switchsrc element");
+}
+
+static void
+gst_switch_src_class_init (GstSwitchSrcClass * klass)
+{
+  GObjectClass *oklass = G_OBJECT_CLASS (klass);
+  GstElementClass *eklass = GST_ELEMENT_CLASS (klass);
+  static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+      GST_PAD_SRC,
+      GST_PAD_ALWAYS,
+      GST_STATIC_CAPS_ANY);
+  GstPadTemplate *child_pad_templ;
+
+  oklass->dispose = gst_switch_src_dispose;
+  eklass->change_state = gst_switch_src_change_state;
+
+  /* Provide a default pad template if the child didn't */
+  child_pad_templ = gst_element_class_get_pad_template (eklass, "src");
+  if (child_pad_templ == NULL) {
+    gst_element_class_add_static_pad_template (eklass, &src_template);
+  }
+}
+
+static gboolean
+gst_switch_src_reset (GstSwitchSrc * src)
+{
+  /* this will install fakesrc if no other child has been set,
+   * otherwise we rely on the subclass to know when to unset its
+   * custom kid */
+  if (src->kid == NULL) {
+    return gst_switch_src_set_child (src, NULL);
+  }
+
+  return TRUE;
+}
+
+static void
+gst_switch_src_init (GstSwitchSrc * src, GstSwitchSrcClass * g_class)
+{
+  GstElementClass *eklass = GST_ELEMENT_GET_CLASS (src);
+  GstPadTemplate *templ;
+
+  templ = gst_element_class_get_pad_template (eklass, "src");
+  src->pad = gst_ghost_pad_new_no_target_from_template ("src", templ);
+  gst_element_add_pad (GST_ELEMENT (src), src->pad);
+
+  gst_switch_src_reset (src);
+
+  GST_OBJECT_FLAG_SET (src, GST_ELEMENT_IS_SOURCE);
+}
+
+static void
+gst_switch_src_dispose (GObject * object)
+{
+  GstSwitchSrc *src = GST_SWITCH_SRC (object);
+  GstObject *new_kid, *kid;
+
+  GST_OBJECT_LOCK (src);
+  new_kid = GST_OBJECT_CAST (src->new_kid);
+  src->new_kid = NULL;
+
+  kid = GST_OBJECT_CAST (src->kid);
+  src->kid = NULL;
+  GST_OBJECT_UNLOCK (src);
+
+  gst_object_replace (&new_kid, NULL);
+  gst_object_replace (&kid, NULL);
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static gboolean
+gst_switch_src_commit_new_kid (GstSwitchSrc * src)
+{
+  GstPad *targetpad;
+  GstState kid_state;
+  GstElement *new_kid, *old_kid;
+  gboolean is_fakesrc = FALSE;
+  GstBus *bus;
+
+  /* need locking around member accesses */
+  GST_OBJECT_LOCK (src);
+  /* If we're currently changing state, set the child to the next state
+   * we're transitioning too, rather than our current state which is 
+   * about to change */
+  if (GST_STATE_NEXT (src) != GST_STATE_VOID_PENDING)
+    kid_state = GST_STATE_NEXT (src);
+  else
+    kid_state = GST_STATE (src);
+
+  new_kid = src->new_kid ? gst_object_ref (src->new_kid) : NULL;
+  src->new_kid = NULL;
+  GST_OBJECT_UNLOCK (src);
+
+  /* Fakesrc by default if NULL is passed as the new child */
+  if (new_kid == NULL) {
+    GST_DEBUG_OBJECT (src, "Replacing kid with fakesrc");
+    new_kid = gst_element_factory_make ("fakesrc", "testsrc");
+    if (new_kid == NULL) {
+      GST_ERROR_OBJECT (src, "Failed to create fakesrc");
+      return FALSE;
+    }
+    /* Add a reference, as it would if the element came from src->new_kid */
+    gst_object_ref (new_kid);
+    is_fakesrc = TRUE;
+  } else {
+    GST_DEBUG_OBJECT (src, "Setting new kid");
+  }
+
+  /* set temporary bus of our own to catch error messages from the child
+   * (could we just set our own bus on it, or would the state change messages
+   * from the not-yet-added element confuse the state change algorithm? Let's
+   * play it safe for now) */
+  bus = gst_bus_new ();
+  gst_element_set_bus (new_kid, bus);
+  gst_object_unref (bus);
+
+  if (gst_element_set_state (new_kid, kid_state) == GST_STATE_CHANGE_FAILURE) {
+    GstMessage *msg;
+
+    /* check if child posted an error message and if so re-post it on our bus
+     * so that the application gets to see a decent error and not our generic
+     * fallback error message which is completely indecipherable to the user */
+    msg = gst_bus_pop_filtered (GST_ELEMENT_BUS (new_kid), GST_MESSAGE_ERROR);
+    if (msg) {
+      GST_INFO_OBJECT (src, "Forwarding kid error: %" GST_PTR_FORMAT, msg);
+      gst_element_post_message (GST_ELEMENT (src), msg);
+    }
+    GST_ELEMENT_ERROR (src, CORE, STATE_CHANGE, (NULL),
+        ("Failed to set state on new child."));
+    gst_element_set_bus (new_kid, NULL);
+    gst_object_unref (new_kid);
+    return FALSE;
+  }
+  gst_element_set_bus (new_kid, NULL);
+  gst_bin_add (GST_BIN (src), new_kid);
+
+  /* Now, replace the existing child */
+  GST_OBJECT_LOCK (src);
+  old_kid = src->kid;
+  src->kid = new_kid;
+  /* Mark whether a custom kid or fakesrc has been installed */
+  src->have_kid = !is_fakesrc;
+  GST_OBJECT_UNLOCK (src);
+
+  /* kill old element */
+  if (old_kid) {
+    GST_DEBUG_OBJECT (src, "Removing old kid %" GST_PTR_FORMAT, old_kid);
+    gst_element_set_state (old_kid, GST_STATE_NULL);
+    gst_bin_remove (GST_BIN (src), old_kid);
+    gst_object_unref (old_kid);
+    /* Don't lose the SOURCE flag */
+    GST_OBJECT_FLAG_SET (src, GST_ELEMENT_IS_SOURCE);
+  }
+
+  /* re-attach ghostpad */
+  GST_DEBUG_OBJECT (src, "Creating new ghostpad");
+  targetpad = gst_element_get_static_pad (src->kid, "src");
+  gst_ghost_pad_set_target (GST_GHOST_PAD (src->pad), targetpad);
+  gst_object_unref (targetpad);
+  GST_DEBUG_OBJECT (src, "done changing child of switchsrc");
+
+  return TRUE;
+}
+
+gboolean
+gst_switch_src_set_child (GstSwitchSrc * src, GstElement * new_kid)
+{
+  GstState cur, next;
+  GstElement **p_kid;
+
+  /* Nothing to do if clearing the child and we've already installed fakesrc */
+  if (new_kid == NULL && src->kid != NULL && src->have_kid == FALSE)
+    return TRUE;
+
+  /* Store the new kid to be committed later */
+  GST_OBJECT_LOCK (src);
+  cur = GST_STATE (src);
+  next = GST_STATE_NEXT (src);
+  p_kid = &src->new_kid;
+  gst_object_replace ((GstObject **) p_kid, (GstObject *) new_kid);
+  GST_OBJECT_UNLOCK (src);
+  if (new_kid)
+    gst_object_unref (new_kid);
+
+  /* Sometime, it would be lovely to allow src changes even when
+   * already running */
+  /* FIXME: Block the pad and replace the kid when it completes */
+  if (cur > GST_STATE_READY || next == GST_STATE_PAUSED) {
+    GST_DEBUG_OBJECT (src,
+        "Switch-src is already running. Ignoring change of child.");
+    gst_object_unref (new_kid);
+    return TRUE;
+  }
+
+  return gst_switch_src_commit_new_kid (src);
+}
+
+static GstStateChangeReturn
+gst_switch_src_change_state (GstElement * element, GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstSwitchSrc *src = GST_SWITCH_SRC (element);
+
+  ret = GST_CALL_PARENT_WITH_DEFAULT (GST_ELEMENT_CLASS, change_state,
+      (element, transition), GST_STATE_CHANGE_SUCCESS);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      if (!gst_switch_src_reset (src))
+        ret = GST_STATE_CHANGE_FAILURE;
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsrc.h	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/gstswitchsrc.h	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,57 @@
+/* GStreamer
+ *
+ * Copyright (c) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+ * Copyright (c) 2005 Tim-Philipp Müller <tim centricular net>
+ * Copyright (c) 2007 Jan Schmidt <thaytan@mad.scientist.com>
+ * Copyright (c) 2010 Sebastian Dröge <sebastian.droege@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_SWITCH_SRC_H__
+#define __GST_SWITCH_SRC_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SWITCH_SRC            (gst_switch_src_get_type ())
+#define GST_SWITCH_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SWITCH_SRC, GstSwitchSrc))
+#define GST_SWITCH_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SWITCH_SRC, GstSwitchSrcClass))
+#define GST_IS_SWITCH_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SWITCH_SRC))
+#define GST_IS_SWITCH_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SWITCH_SRC))
+
+typedef struct _GstSwitchSrc {
+  GstBin parent;
+
+  GstElement *kid;
+  GstElement *new_kid;
+  GstPad *pad;
+
+  /* If a custom child has been set... */
+  gboolean have_kid;
+} GstSwitchSrc;
+
+typedef struct _GstSwitchSrcClass {
+  GstBinClass parent_class;
+} GstSwitchSrcClass;
+
+GType     gst_switch_src_get_type   (void);
+gboolean  gst_switch_src_set_child  (GstSwitchSrc *ssrc, GstElement *new_kid);
+
+G_END_DECLS
+
+#endif /* __GST_SWITCH_SRC_H__ */
--- origsrc/gst-plugins-good-0.10.31/ext/mateconf/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/ext/mateconf/Makefile.am	2012-04-18 03:08:19.063307000 -0500
@@ -0,0 +1,27 @@
+plugin_LTLIBRARIES = libgstmateconfelements.la
+
+libgstmateconfelements_la_SOURCES = \
+	gstmateconfaudiosink.c \
+	gstmateconfaudiosrc.c \
+	gstmateconfelements.c \
+	gstmateconfvideosink.c \
+	gstmateconfvideosrc.c \
+	gstswitchsink.c \
+	gstswitchsrc.c \
+	gstmateconf.c
+
+DIR_CFLAGS = -DGST_MATECONF_DIR=\"/system/gstreamer/@GST_MAJORMINOR@\"
+libgstmateconfelements_la_CFLAGS = $(GST_CFLAGS) $(MATECONF_CFLAGS) $(DIR_CFLAGS)
+libgstmateconfelements_la_LIBADD = $(GST_LIBS) $(MATECONF_LIBS)
+libgstmateconfelements_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstmateconfelements_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = \
+	gstmateconfaudiosink.h \
+	gstmateconfaudiosrc.h \
+	gstmateconfelements.h \
+	gstmateconfvideosink.h \
+	gstmateconfvideosrc.h \
+	gstswitchsink.h \
+	gstswitchsrc.h \
+	gstmateconf.h
--- origsrc/gst-plugins-good-0.10.31/gst-plugins-good.spec.in	2011-12-11 12:48:10.000000000 -0600
+++ src/gst-plugins-good-0.10.31/gst-plugins-good.spec.in	2012-04-18 03:35:18.282921000 -0500
@@ -31,6 +31,7 @@ BuildRequires:  gcc-c++
 @USE_LIBCACA_TRUE@BuildRequires: libcaca-devel
 @USE_LIBDV_TRUE@BuildRequires: libdv-devel
 @USE_LIBPNG_TRUE@BuildRequires: libpng-devel >= 1.2.0
+@USE_MATECONF_TRUE@BuildRequires: mate-conf-devel
 @USE_OSS_TRUE@BuildRequires: glibc-devel
 @USE_SPEEX_TRUE@BuildRequires:	speex-devel
 @USE_HAL_TRUE@BuildRequires: hal-devel
@@ -64,8 +65,10 @@ make %{?_smp_mflags}
 rm -rf $RPM_BUILD_ROOT
 
 export GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1
+export MATECONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1
 %makeinstall
 unset GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL
+unset MATECONF_DISABLE_MAKEFILE_SCHEMA_INSTALL
                                                                                 
 # Clean out files that should not be part of the rpm.
 rm -f $RPM_BUILD_ROOT%{_libdir}/gstreamer-%{majorminor}/*.la
@@ -81,6 +84,8 @@ rm -rf $RPM_BUILD_ROOT
 %post
 @USE_GCONF_TRUE@export GCONF_CONFIG_SOURCE=`gconftool-2 --get-default-source`
 @USE_GCONF_TRUE@gconftool-2 --makefile-install-rule %{_sysconfdir}/gconf/schemas/gstreamer-%{majorminor}.schemas > /dev/null
+@USE_MATECONF_TRUE@export MATECONF_CONFIG_SOURCE=`mateconftool-2 --get-default-source`
+@USE_MATECONF_TRUE@mateconftool-2 --makefile-install-rule %{_sysconfdir}/mateconf/schemas/gstreamer-%{majorminor}.schemas > /dev/null
 
 %files -f gst-plugins-good-%{majorminor}.lang
 %defattr(-, root, root)
@@ -154,6 +159,7 @@ rm -rf $RPM_BUILD_ROOT
 @USE_OSS_TRUE@%{_libdir}/gstreamer-%{majorminor}/libgstossaudio.so
 @USE_SPEEX_TRUE@%{_libdir}/gstreamer-%{majorminor}/libgstspeex.so
 @USE_GCONF_TRUE@%{_libdir}/gstreamer-%{majorminor}/libgstgconfelements.so
+@USE_MATECONF_TRUE@%{_libdir}/gstreamer-%{majorminor}/libgstmateconfelements.so
 @USE_HAL_TRUE@%{_libdir}/gstreamer-%{majorminor}/libgsthalelements.so
 @USE_SHOUT2_TRUE@%{_libdir}/gstreamer-%{majorminor}/libgstshout2.so
 @USE_AALIB_TRUE@%{_libdir}/gstreamer-%{majorminor}/libgstaasink.so
@@ -165,6 +171,7 @@ rm -rf $RPM_BUILD_ROOT
 
 # schema files
 @USE_GCONF_TRUE@%{_sysconfdir}/gconf/schemas/gstreamer-%{majorminor}.schemas
+@USE_MATECONF_TRUE@%{_sysconfdir}/mateconf/schemas/gstreamer-%{majorminor}.schemas
 
 %changelog
 * Tue Jun 12 2007 Jan Schmidt <jan at fluendo dot com>
--- origsrc/gst-plugins-good-0.10.31/Makefile.am	2011-12-30 07:59:08.000000000 -0600
+++ src/gst-plugins-good-0.10.31/Makefile.am	2012-04-18 03:07:44.878351700 -0500
@@ -6,6 +6,12 @@ else
 GCONF_DIR =
 endif
 
+if USE_MATECONFTOOL
+MATECONF_DIR = mateconf
+else
+MATECONF_DIR =
+endif
+
 ALWAYS_SUBDIRS =		\
 	gst sys ext 		\
 	tests			\
@@ -17,11 +23,13 @@ ALWAYS_SUBDIRS =		\
 
 SUBDIRS = 			\
 	$(ALWAYS_SUBDIRS)	\
-	$(GCONF_DIR)
+	$(GCONF_DIR)		\
+	$(MATECONF_DIR)
 
 DIST_SUBDIRS = 			\
 	$(ALWAYS_SUBDIRS)	\
-	gconf
+	gconf			\
+	mateconf
 
 
 # include before EXTRA_DIST for win32 assignment
--- origsrc/gst-plugins-good-0.10.31/mateconf/gstreamer.schemas.in	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/mateconf/gstreamer.schemas.in	2012-04-18 02:48:05.000000000 -0500
@@ -0,0 +1,191 @@
+<mateconfschemafile>
+  <schemalist>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/audiosink</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/audiosink</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_AUDIOSINK@</default>
+      <locale name="C">
+        <short>default GStreamer audiosink</short>
+        <long>GStreamer can play audio using any number of output elements.  Some possible choices are osssink, esdsink and alsasink.  The audiosink can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/audiosink_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/audiosink_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for default GStreamer audiosink</short>
+        <long>Describes the selected output element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_AUDIOSINK@</default>
+      <locale name="C">
+        <short>GStreamer audiosink for Music and Movies</short>
+        <long>GStreamer can play audio using any number of output elements.  Some possible choices are osssink, esdsink and alsasink.  The audiosink can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for GStreamer audiosink for Music and Movies</short>
+        <long>Describes the selected output element for Music and Movies.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_AUDIOSINK@</default>
+      <locale name="C">
+        <short>GStreamer audiosink for Audio/Video Conferencing</short>
+        <long>GStreamer can play audio using any number of output elements.  Some possible choices are osssink, esdsink and alsasink.  The audiosink can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for GStreamer audiosink for Audio/Video Conferencing</short>
+        <long>Describes the selected output element for Audio/Video Conferencing.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/audiosink_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/audiosink_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for default GStreamer audiosink</short>
+        <long>Describes the selected output element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_AUDIOSINK@</default>
+      <locale name="C">
+        <short>GStreamer audiosink for Music and Movies</short>
+        <long>GStreamer can play audio using any number of output elements.  Some possible choices are osssink, esdsink and alsasink.  The audiosink can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/musicaudiosink_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for GStreamer audiosink for Music and Movies</short>
+        <long>Describes the selected output element for Music and Movies.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_AUDIOSINK@</default>
+      <locale name="C">
+        <short>GStreamer audiosink for Audio/Video Conferencing</short>
+        <long>GStreamer can play audio using any number of output elements.  Some possible choices are osssink, esdsink and alsasink.  The audiosink can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/chataudiosink_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for GStreamer audiosink for Audio/Video Conferencing</short>
+        <long>Describes the selected output element for Audio/Video Conferencing.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/videosink</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/videosink</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_VIDEOSINK@</default>
+      <locale name="C">
+        <short>default GStreamer videosink</short>
+        <long>GStreamer can play video using any number of output elements.  Some possible choices are xvimagesink, ximagesink, sdlvideosink and aasink.  The videosink can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/audiosrc</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/audiosrc</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_AUDIOSRC@</default>
+      <locale name="C">
+        <short>default GStreamer audio source</short>
+        <long>GStreamer can record audio using any number of input elements.  Some possible choices are osssrc, esdsrc and alsasrc.  The audio source can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/audiosrc_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/audiosrc_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for default GStreamer audiosrc</short>
+        <long>Describes the selected input element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/audiosrc_description</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/audiosrc_description</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>Default</default>
+      <locale name="C">
+        <short>description for default GStreamer audiosrc</short>
+        <long>Describes the selected input element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/videosrc</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/videosrc</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_VIDEOSRC@</default>
+      <locale name="C">
+        <short>default GStreamer video source</short>
+        <long>GStreamer can record video from any number of input elements.  Some possible choices are v4lsrc and videotestsrc. The video source can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/system/gstreamer/@GST_MAJORMINOR@/default/visualization</key>
+      <applyto>/system/gstreamer/@GST_MAJORMINOR@/default/visualization</applyto>
+      <owner>gstreamer</owner>
+      <type>string</type>
+      <default>@DEFAULT_VISUALIZER@</default>
+      <locale name="C">
+        <short>default GStreamer visualization plugin</short>
+        <long>GStreamer can put visualization plugins in a pipeline to transform audio stream in video frames. Default is goom but more visualization plugins will be ported soon. The visualization plugin can be a partial pipeline instead of just one element.</long>
+      </locale>
+    </schema>
+  </schemalist>
+</mateconfschemafile>
--- origsrc/gst-plugins-good-0.10.31/mateconf/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ src/gst-plugins-good-0.10.31/mateconf/Makefile.am	2012-04-18 03:09:16.157572600 -0500
@@ -0,0 +1,31 @@
+GST_SCHEMA_FILES = gstreamer-@GST_MAJORMINOR@.schemas
+
+if USE_MATECONF
+schemadir = @MATECONF_SCHEMA_FILE_DIR@
+schema_DATA = $(GST_SCHEMA_FILES)
+endif
+
+gstreamer-@GST_MAJORMINOR@.schemas: gstreamer.schemas
+	cp gstreamer.schemas gstreamer-@GST_MAJORMINOR@.schemas
+
+if USE_MATECONF
+if MATECONF_SCHEMAS_INSTALL
+install-data-local:
+	@MATECONF_CONFIG_SOURCE=$(MATECONF_SCHEMA_CONFIG_SOURCE) $(MATECONFTOOL) \
+		--makefile-install-rule $(builddir)/$(schema_DATA) || \
+		(echo ;\
+		echo "*****************************************************"; \
+		echo "Installation of schemas failed, install them manually"; \
+		echo "*****************************************************";) 
+	@true
+else
+install-data-local:
+	@echo "***************************************************************"
+	@echo "Not installing schemas, disabled with --disable-schemas-install"
+	@echo "***************************************************************"
+	@true
+endif
+endif # USE_MATECONF
+
+CLEANFILES = $(GST_SCHEMA_FILES)
+EXTRA_DIST = $(GST_SCHEMA_FILES)
--- origsrc/gst-plugins-good-0.10.31/tests/check/Makefile.am	2011-12-30 07:59:13.000000000 -0600
+++ src/gst-plugins-good-0.10.31/tests/check/Makefile.am	2012-04-18 03:33:03.734225300 -0500
@@ -14,6 +14,7 @@ TESTS_ENVIRONMENT = \
 	GST_STATE_IGNORE_ELEMENTS="aasink autoaudiosrc autoaudiosink autovideosrc autovideosink \
 		cacasink cairotextoverlay gconfaudiosrc gconfvideosrc gconfaudiosink gconfvideosink \
 		halaudiosrc halaudiosink jackaudiosrc jackaudiosink \
+		mateconfaudiosrc mateconfvideosrc mateconfaudiosink mateconfvideosink \
 		osssrc osssink osxaudiosink osxaudiosrc osxvideosrc osxvideosink \
 		pulsesink pulsesrc pulsemixer v4l2src"
 
